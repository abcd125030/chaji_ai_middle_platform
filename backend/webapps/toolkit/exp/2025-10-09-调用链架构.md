# PDF提取器调用链架构

## 概述

本文档描述了PDF提取器功能的完整调用链架构，从前端请求到后端处理的各个环节。

## 架构图

```
前端请求
    ↓
Django Views (接口层)
    ↓
Utils (辅助工具层)
    ├── FileManager (文件管理)
    ├── RequestValidator (请求验证)
    └── TaskProgressManager (进度管理)
    ↓
Models (数据模型层)
    └── PDFExtractorTask (任务模型)
    ↓
Celery Tasks (异步任务层)
    └── process_pdf_extraction
    ↓
Services (服务层)
    └── PDFExtractorService
        ├── pdf_to_image
        ├── analyze_image_regions
        ├── extract_region
        ├── process_page
        ├── process_pdf_document
        ├── save_task_progress
        └── generate_markdown
    ↓
文件系统
    └── media/oss-bucket/_toolkit/_extractor/{uuid}/
        ├── {uuid}.pdf                 # PDF文件使用UUID命名
        ├── task.json                  # 任务进度JSON
        ├── {result}.md                # 生成的markdown文档
        └── images/                    # 提取的图片目录
            ├── page001_region01_*.png
            └── ...
```

## 调用链详细说明

### 1. 上传PDF文档接口

**端点**: `POST /api/toolkit/extractor/upload/`

**调用流程**:
```
views.upload_pdf_documents()
    ↓
RequestValidator.validate_file_list()  # 验证文件列表
    ↓
FileManager.ensure_directory()  # 确保基础目录存在
    ↓
Loop for each file:
    ↓
    PDFExtractorTask.objects.create()  # 创建任务记录
    ↓
    FileManager.create_task_directory()  # 创建任务目录
    ↓
    FileManager.save_base64_file()  # 保存PDF文件 (TODO)
    ↓
    process_pdf_extraction.delay()  # 提交Celery异步任务
    ↓
返回任务UUID列表
```

### 2. Celery异步任务处理

**任务**: `toolkit.process_pdf_extraction`

**调用流程**:
```
tasks.process_pdf_extraction(task_id, file_path)
    ↓
PDFExtractorTask.objects.get(id=task_id)  # 获取任务记录
    ↓
task.status = 'processing'  # 更新状态
    ↓
PDFExtractorService.process_pdf_document(file_path, task_id)  # 处理完整PDF (TODO)
    ↓
    Loop for each page (页码: 1 to N):
        ↓
        创建页面目录: page_{num}/
        ↓
        【步骤1: 提取文本】
        ↓
        extract_page_text()  # 提取页面文本
        ↓
        保存为 page_{num}.md  # 原始文本markdown
        ↓
        【步骤2: 生成完整页面图片】
        ↓
        pdf_to_image()  # 转换页面为图像
        ↓
        保存为 page_{num}/full_page.png  # 完整页面截图
        ↓
        【步骤3: 语义分割 - 完全模仿 qwen3vl_segmentation.py】
        ↓
        analyze_image_regions()  # 使用Qwen3-VL-Plus语义分割
            ├─ 使用与qwen3vl_segmentation.py完全一致的提示词
            ├─ 识别diagram_area/chart_area/image_text_area/table_area/formula_area
            └─ 返回区域列表
        ↓
        extract_region()  # 提取各个分割区域
        ↓
        保存为 page_{num}/image_{num}.png  # 按序号保存分割图片
        ↓
        【步骤4: 使用Qwen3-VL重构Markdown】
        ↓
        构建消息结构:
            message = [
                {"type": "text", "text": page_{num}.md的内容},
                {"type": "image_url", "image_url": "data:image/png;base64,{full_page.png}"},
                {"type": "image_url", "image_url": "data:image/png;base64,{image_1.png}"},
                {"type": "image_url", "image_url": "data:image/png;base64,{image_2.png}"},
                ...
                {"type": "text", "text": 重构提示词}
            ]
        ↓
        重构提示词内容:
            """根据完整页面图片的内容排版和语义，将分割图片以markdown格式
            插入到文本内容的正确位置。

            分割图片路径对应关系：
            - 消息体中第3张图片(image_1) -> media/oss-bucket/_toolkit/_extractor/{uuid}/page_1/image_1.png
            - 消息体中第4张图片(image_2) -> media/oss-bucket/_toolkit/_extractor/{uuid}/page_1/image_2.png
            ...

            请返回新的markdown内容，图片使用相对路径: page_1/image_1.png
            """
        ↓
        调用Qwen3-VL-Plus生成新的markdown
        ↓
        保存为 page_{num}_final.md  # 最终重构后的markdown
        ↓
        TaskProgressManager.update_page_status()  # 更新页面状态
        ↓
        PDFExtractorService.save_task_progress()  # 更新task.json
    ↓
    PDFExtractorService.merge_page_markdowns()  # 合并所有页面markdown (TODO)
    ↓
    保存为 {task_id}_result.md  # 最终完整文档
    ↓
task.status = 'completed'  # 更新状态
```

**关键实现要点**:

1. **文本提取**: 使用PyMuPDF (fitz)提取每页文本，保持原有顺序
2. **完整截图**: 每页生成一张完整的PNG图片作为排版参考
3. **语义分割**:
   - 使用与`qwen3vl_segmentation.py`完全相同的提示词
   - 识别5类视觉元素区域
   - 按顺序保存为`image_1.png`, `image_2.png`等
4. **图片编码**: 所有图片转为base64发送给模型（避免本地环境URL访问问题）
5. **Markdown重构**:
   - 模型输入: 原始文本 + 完整图片 + 分割图片序列
   - 模型任务: 根据完整图片的排版，将分割图片插入到文本正确位置
   - 图片路径: 使用相对路径`page_{num}/image_{num}.png`

### 3. 查询任务进度接口

**端点**: `POST /api/toolkit/extractor/progress/`

**调用流程**:
```
views.query_task_progress()
    ↓
RequestValidator.validate_task_ids()  # 验证任务ID列表
    ↓
Loop for each task_id:
    ↓
    PDFExtractorTask.objects.get(id=task_id)  # 获取任务记录
    ↓
    FileManager.get_task_json_path()  # 获取task.json路径 (TODO)
    ↓
    读取task.json文件 (TODO)
    ↓
    构建进度信息
    ↓
返回进度列表
```

### 4. 获取任务内容接口

**端点**: `GET /api/toolkit/extractor/content/{task_id}/`

**调用流程**:
```
views.get_task_content(task_id)
    ↓
PDFExtractorTask.objects.get(id=task_id)  # 获取任务记录
    ↓
检查任务状态 (必须是completed)
    ↓
FileManager.get_markdown_path()  # 获取markdown文件路径 (TODO)
    ↓
读取markdown内容 (TODO)
    ↓
FileManager.get_images_directory()  # 获取images目录 (TODO)
    ↓
列出所有图片文件 (TODO)
    ↓
返回markdown内容和图片列表
```

## 数据结构

### PDFExtractorTask 模型

```python
{
    "id": UUID,
    "original_filename": str,
    "file_path": str,
    "status": "pending|processing|completed|error",
    "total_pages": int,
    "processed_pages": int,
    "created_at": datetime,
    "updated_at": datetime
}
```

### task.json 文件结构

```json
{
    "task_id": "uuid",
    "status": "pending|processing|completed|error",
    "total_pages": 10,
    "processed_pages": 5,
    "pages": [
        {
            "page": 1,
            "status": "completed",
            "regions": [...],
            "images": [...]
        },
        {
            "page": 2,
            "status": "processing"
        }
    ]
}
```

## 文件目录结构

```
backend/media/oss-bucket/_toolkit/_extractor/
└── {task-uuid}/
    ├── {task-uuid}.pdf                      # PDF文件使用UUID命名（原始文件名保存在数据库）
    ├── task.json                            # 任务进度JSON
    ├── {task-uuid}_result.md                # 最终完整markdown文档
    │
    ├── page_1/                              # 第1页处理目录
    │   ├── page_1.md                        # 第1页原始文本提取
    │   ├── page_1_final.md                  # 第1页重构后的markdown
    │   ├── full_page.png                    # 第1页完整截图
    │   ├── image_1.png                      # 第1页语义分割图片1
    │   ├── image_2.png                      # 第1页语义分割图片2
    │   └── ...                              # 更多分割图片
    │
    ├── page_2/                              # 第2页处理目录
    │   ├── page_2.md
    │   ├── page_2_final.md
    │   ├── full_page.png
    │   ├── image_1.png
    │   └── ...
    │
    └── page_N/                              # 第N页处理目录
        └── ...
```

**目录说明**：

1. **根目录文件**:
   - `{task-uuid}.pdf`: 原始PDF文件（UUID命名，原始文件名在数据库中）
   - `task.json`: 任务进度跟踪文件
   - `{task-uuid}_result.md`: 所有页面合并后的最终markdown文档

2. **页面目录** (`page_N/`):
   - `page_N.md`: 使用PyMuPDF提取的原始文本
   - `full_page.png`: 页面完整截图（用于排版参考）
   - `image_N.png`: 语义分割提取的视觉元素图片（按序号命名）
   - `page_N_final.md`: 经过Qwen3-VL重构后的markdown（图片已插入正确位置）

3. **文件命名规则**:
   - PDF文件: `{uuid}.pdf`（例如：`550e8400-e29b-41d4-a716-446655440000.pdf`）
   - 页面目录: `page_1`, `page_2`, ...（从1开始）
   - 分割图片: `image_1.png`, `image_2.png`, ...（按识别顺序）

4. **数据库关系**:
   - UUID与原始文件名对应关系保存在`PDFExtractorTask.original_filename`字段

## 配置管理

### PDFExtractorConfig 配置项

```python
{
    "base_dir": "media/oss-bucket/_toolkit/_extractor",
    "max_files": 20,
    "max_file_size_mb": 50,
    "dpi": 300,
    "image_format": "PNG",
    "supported_formats": [".pdf"],
    "qwen_model": "qwen-vl-plus",
    "task_retention_days": 30
}
```

## TODO 清单

### 高优先级
1. `FileManager.save_base64_file()` - 实现base64文件保存
2. `PDFExtractorService.process_pdf_document()` - 实现完整PDF处理
3. `PDFExtractorService.save_task_progress()` - 实现进度保存
4. `PDFExtractorService.generate_markdown()` - 实现markdown生成

### 中优先级
5. `views.query_task_progress()` - 读取task.json文件
6. `views.get_task_content()` - 读取markdown和图片
7. `TaskProgressManager.update_page_status()` - 更新页面状态
8. `TaskProgressManager.update_task_status()` - 更新任务状态

### 低优先级
9. `FileManager.validate_pdf_file()` - PDF文件验证
10. `FileManager.cleanup_task_files()` - 文件清理
11. `RequestValidator.validate_file_list()` - 完善文件验证
12. `tasks.cleanup_old_tasks()` - 实现任务清理

## 测试建议

### 单元测试
- 测试文件验证逻辑
- 测试任务创建流程
- 测试进度更新逻辑
- 测试文件读写操作

### 集成测试
- 测试完整上传流程
- 测试Celery任务执行
- 测试进度查询
- 测试内容获取

### 性能测试
- 并发上传多个文件
- 大文件处理性能
- 查询接口响应时间

## 注意事项

1. **文件安全**: 所有上传的文件需要验证格式和大小
2. **并发处理**: Celery任务需要处理并发和重试逻辑
3. **错误处理**: 各环节需要完善的异常处理和日志记录
4. **资源清理**: 定期清理过期任务和文件
5. **权限控制**: 考虑添加用户权限验证
