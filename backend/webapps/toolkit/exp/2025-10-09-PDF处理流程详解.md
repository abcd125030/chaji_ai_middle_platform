# PDF提取器完整处理流程详解

## 概述

本文档详细说明PDF提取器如何将PDF文档转换为包含正确图文排版的Markdown文档。

## 核心理念

**目标**: 将PDF文档转换为高质量的Markdown文档，保持原有的图文排版和语义结构。

**方法**:
1. 分离文本和视觉内容
2. 使用AI理解图文排版关系
3. 智能重构Markdown文档

## 完整处理流程

### 阶段1: 文件接收与准备

```
前端上传PDF（base64编码）
    ↓
Django接口创建任务记录
    ↓
保存PDF文件为 {uuid}.pdf
    ↓
提交Celery异步任务
```

### 阶段2: 逐页处理（核心流程）

对PDF的每一页执行以下4个步骤：

#### 步骤1: 提取文本

**目标**: 获取页面的纯文本内容

```python
text = extract_page_text(pdf_path, page_number)
保存为: page_{num}.md
```

**实现**:
- 使用 PyMuPDF (fitz) 提取文本
- 保持原有文本顺序
- 输出纯文本Markdown格式

**输出示例** (`page_1.md`):
```markdown
# 系统架构说明

本系统采用微服务架构，包含以下核心组件：

API网关
用户服务
订单服务
支付服务

各服务之间通过消息队列进行通信...
```

#### 步骤2: 生成完整页面截图

**目标**: 保存页面的完整视觉效果，用于后续AI理解排版

```python
image = pdf_to_image(pdf_path, page_number, dpi=300)
保存为: page_{num}/full_page.png
```

**用途**:
- 作为排版参考
- 帮助AI理解图文位置关系
- 确定分割图片应该插入的位置

#### 步骤3: 语义分割（核心技术）

**目标**: 识别并提取页面中的视觉元素

```python
# 使用Qwen3-VL-Plus进行语义分割
regions = analyze_image_regions(image)

# 提取每个区域
for i, region in enumerate(regions):
    region_image = extract_region(image, region)
    保存为: page_{num}/image_{i+1}.png
```

**重要**: 必须使用与 `qwen3vl_segmentation.py` 完全一致的提示词

**识别的5类视觉元素**:
1. `diagram_area` - 示意图、架构图、流程图
2. `chart_area` - 数据图表（柱状图、饼图等）
3. `image_text_area` - 图文混合（产品图+说明）
4. `table_area` - 结构化表格
5. `formula_area` - 数学公式、化学式

**语义分割提示词** (必须完全一致):
```python
prompt = """你是一个专业的文档视觉内容提取专家。你的任务是从文档页面中识别和提取有视觉价值的内容区域，用于后续的Markdown文档重构。

核心任务：
只提取包含视觉元素的内容区域，这些区域在转换为Markdown时需要以图片形式保留。

需要提取的内容（仅限以下类型）：
1. 示意图区域（diagram_area）：包含示意图、架构图、流程图及其相关说明文字
2. 图表区域（chart_area）：包含数据图表（柱状图、饼图、折线图等）及其标题说明
3. 图文混合区域（image_text_area）：包含产品图片、设备照片等与其说明文字的组合
4. 表格区域（table_area）：包含结构化表格，特别是带图标或视觉元素的表格
5. 公式区域（formula_area）：数学公式、化学式等特殊符号内容

不要提取的内容（忽略以下内容）：
- 纯文本段落（这些会通过其他方式提取）
- 单独的标题文字
- 页眉页脚
- 页码
- 单纯的文字列表（没有图标或视觉元素的）

关键原则：
- 每个区域必须是一个完整的视觉单元（图+其直接相关的说明文字）
- 紧密贴合内容边界，不要包含多余的空白或无关内容
- 如果有多个独立的视觉组，应该分别提取，而不是合并成一个大区域
- 判断标准：这个区域是否需要以图片形式保留在最终的Markdown中？
- 边界要精确：只框选实际内容，不要为了"安全"而扩大范围

输出格式要求：
请严格按照以下JSON格式返回结果，使用像素坐标：

{
    "bbox_format": "left_top_x, left_top_y, right_bottom_x, right_bottom_y",
    "regions": [
        {
            "id": 1,
            "type": "image_text_area",
            "description": "设备介绍区域，包含6个设备图片及其功能说明",
            "bbox": [100, 200, 900, 600],
            "bbox_meaning": {
                "left_top_x": 100,
                "left_top_y": 200,
                "right_bottom_x": 900,
                "right_bottom_y": 600
            },
            "confidence": 0.95,
            "semantic_label": "equipment_showcase"
        }
    ]
}

重要的坐标系统说明：
- 使用像素坐标（绝对坐标）
- bbox格式必须是：[left_top_x, left_top_y, right_bottom_x, right_bottom_y]
  - left_top_x: 左上角的x像素坐标
  - left_top_y: 左上角的y像素坐标
  - right_bottom_x: 右下角的x像素坐标（必须大于left_top_x）
  - right_bottom_y: 右下角的y像素坐标（必须大于left_top_y）
- 每个区域必须同时提供bbox和bbox_meaning字段，确保坐标含义清晰
- 精确性要求：
  - 边界要紧贴内容，不要包含大片空白
  - 宁可稍微紧一点，也不要框得太松

请直接返回JSON格式的结果，不要包含其他解释文字。"""
```

**输出示例**:
- `page_1/image_1.png` - 系统架构图
- `page_1/image_2.png` - 服务部署表格
- `page_1/image_3.png` - 性能对比图表

#### 步骤4: Markdown重构（关键创新）

**目标**: 使用AI将分割图片插入到文本的正确位置

**输入数据**:
1. 原始文本 (`page_1.md`)
2. 完整页面截图 (`full_page.png`)
3. 分割图片列表 (`image_1.png`, `image_2.png`, ...)

**构建Qwen3-VL请求**:

```python
# 所有图片转为base64（避免本地URL访问问题）
full_page_base64 = encode_image_to_base64(full_page_image)
image_1_base64 = encode_image_to_base64(region_images[0])
image_2_base64 = encode_image_to_base64(region_images[1])
# ...

# 构建消息体
message = [
    {
        "type": "text",
        "text": page_text  # page_1.md的文本内容
    },
    {
        "type": "image_url",
        "image_url": {"url": f"data:image/png;base64,{full_page_base64}"}
    },
    {
        "type": "image_url",
        "image_url": {"url": f"data:image/png;base64,{image_1_base64}"}
    },
    {
        "type": "image_url",
        "image_url": {"url": f"data:image/png;base64,{image_2_base64}"}
    },
    # ... 更多分割图片
    {
        "type": "text",
        "text": reconstruction_prompt  # 重构提示词（见下方）
    }
]
```

**重构提示词**:

```python
reconstruction_prompt = f"""请根据完整页面图片的内容排版和正确的文图语义关系，将分割图片以markdown图片引用格式插入到文本内容的正确位置。

## 图片路径对应关系

消息体中的图片顺序和文件路径的对应关系如下：
- 第2张图片（完整页面）: 仅供排版参考，不需要插入
- 第3张图片（分割图1）-> `page_{page_number}/image_1.png`
- 第4张图片（分割图2）-> `page_{page_number}/image_2.png`
- 第5张图片（分割图3）-> `page_{page_number}/image_3.png`
... （根据实际分割图片数量列出）

## 任务要求

1. **理解排版**: 仔细观察完整页面图片，理解文本和图片的空间位置关系
2. **语义匹配**: 根据文本内容和图片内容的语义关系，判断每张图片应该插入的位置
3. **正确插入**: 在文本的合适位置插入markdown图片引用
4. **路径格式**: 使用相对路径格式: `![描述](page_{page_number}/image_N.png)`
5. **保持原文**: 不要修改原有文本内容，只添加图片引用

## 输出要求

直接返回重构后的完整markdown内容，不需要任何额外的解释说明。

## 示例

原文本：
```
# 系统架构
本系统包含以下组件...
```

重构后：
```
# 系统架构

![系统架构图](page_1/image_1.png)

本系统包含以下组件...
```

请现在开始处理，返回重构后的markdown内容。
"""
```

**调用API**:
```python
response = qwen3_vl_client.chat.completions.create(
    model="qwen3-vl-plus",
    messages=[{"role": "user", "content": message}],
    temperature=0.1
)

reconstructed_md = response.choices[0].message.content
保存为: page_{num}_final.md
```

**输出示例** (`page_1_final.md`):
```markdown
# 系统架构说明

本系统采用微服务架构，包含以下核心组件：

![系统架构图](page_1/image_1.png)

API网关、用户服务、订单服务、支付服务等组件通过消息队列进行通信。

![服务部署拓扑](page_1/image_2.png)

各服务的性能对比如下：

![性能对比图表](page_1/image_3.png)
```

### 阶段3: 合并与完成

```python
# 合并所有页面的markdown
merge_page_markdowns(task_dir, page_count, task_id)
保存为: {task_id}_result.md

# 更新任务状态
task.status = 'completed'
task.save()
```

## 文件组织结构

处理完成后的文件结构：

```
{task-uuid}/
├── {task-uuid}.pdf              # 原始PDF
├── task.json                    # 进度跟踪
├── {task-uuid}_result.md        # 最终完整文档 ⭐
│
├── page_1/
│   ├── page_1.md                # 原始文本
│   ├── page_1_final.md          # 重构后的markdown ⭐
│   ├── full_page.png            # 完整截图（排版参考）
│   ├── image_1.png              # 分割图片1
│   ├── image_2.png              # 分割图片2
│   └── ...
│
└── page_N/
    └── ...
```

## 技术要点总结

### 1. 为什么使用base64编码图片？

在本地开发环境（127.0.0.1），Qwen3-VL模型无法访问本地文件路径或localhost URL。使用base64编码可以直接将图片数据嵌入到API请求中。

### 2. 为什么需要完整页面截图？

AI需要理解文本和图片在页面上的空间位置关系，才能准确判断图片应该插入到文本的哪个位置。完整截图提供了这个上下文。

### 3. 语义分割提示词为什么要完全一致？

`qwen3vl_segmentation.py` 中的提示词经过精心设计和测试，能够准确识别5类视觉元素。保持一致性确保分割质量稳定。

### 4. 如何确保图片路径正确？

在重构提示词中明确列出每张图片在消息体中的位置和对应的文件路径，让AI清楚知道应该使用哪个路径。

## 进度跟踪

`task.json` 文件实时记录处理进度：

```json
{
    "task_id": "uuid",
    "status": "processing",
    "total_pages": 10,
    "processed_pages": 3,
    "pages": [
        {
            "page": 1,
            "status": "completed",
            "text_extracted": true,
            "regions_count": 3,
            "reconstructed": true
        },
        {
            "page": 2,
            "status": "processing"
        }
    ]
}
```

## 错误处理

- PDF读取失败 → status: 'error'
- 文本提取失败 → 使用空文本继续
- 语义分割失败 → 仅使用文本，不插入图片
- Markdown重构失败 → 使用原始文本+图片列表

## 性能优化建议

1. **并行处理**: 可以并行处理多个页面（注意API限流）
2. **缓存机制**: 缓存已处理的页面结果
3. **渐进式更新**: 每处理完一页立即更新进度
4. **资源清理**: 定期清理过期任务的文件

## 未来优化方向

1. 支持表格OCR识别，转换为markdown表格格式
2. 支持公式识别，转换为LaTeX格式
3. 支持多语言文档处理
4. 优化大型PDF的处理速度
