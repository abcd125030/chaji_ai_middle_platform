# 测试规范 (修订版)

## 核心原则

1.  **在隔离环境中重建真实状态**：测试应在由 Django `TestCase` 创建的独立、干净的数据库中运行，以保证可重复性。我们通过在测试开始时**一次性加载**生产环境中的必要配置和数据，来模拟一个“真实”的初始状态。
2.  **禁止业务逻辑模拟**：所有测试必须调用真实的业务逻辑、服务和工具实现（`llm/`, `tools/` 等），禁止使用 `mock` 或 `patch` 绕过核心业务流程。

## 测试生命周期管理

为了高效地准备测试环境，我们遵循 Django `TestCase` 的生命周期：

*   **`setUpTestData(cls)`** (类级别，执行一次):
    *   **用途**: 连接到真实数据库（如果需要）读取配置，然后在**测试数据库**中创建这些配置。加载所有测试用例共享的、不会被修改的“背景”数据。
    *   **目标**: 模拟一个已配置好的生产环境的起点。
*   **`setUp(self)`** (方法级别，每个测试前执行):
    *   **用途**: 准备每个独立测试用例所需的状态，例如创建特定的用户数据。同时，设置日志记录、捕获测试开始时的状态快照。
    *   **目标**: 为即将运行的单个测试用例设置上下文。

## 强制要求

### 1. 使用隔离的“真实”数据库
- 所有测试必须在 Django `TestCase` 提供的**临时测试数据库**中运行。
- **【新增】** 使用 `setUpTestData` 在测试类初始化时，将 `config` 表中的真实配置项**创建**到测试数据库中。这确保了测试环境的一致性和真实性，同时避免了多次重复创建。
- 测试前通过 `setUp` 记录初始状态，测试后记录最终状态。
- 所有数据库变更必须可追踪并记录在输出文件中。

### 2. 使用真实的模型配置
- 从 `router/` 目录读取真实的模型配置。
- **【修改】** 从**已通过 `setUpTestData` 填充好**的测试数据库 `config` 表中读取配置项。
- 禁止在业务逻辑测试中硬编码模型参数。

*(其他要求 3, 4, 5 保持不变，因为它们与数据准备阶段的关联较小)*

---

## 测试代码模板 (修订版)

```python
import os
import json
import logging
from datetime import datetime
from django.test import TestCase
from django.conf import settings
from django.db import transaction

# 导入你的配置模型，例如：
# from your_infra_app.models import InfraConfig

class RealTestCase(TestCase):
    """
    真实测试基类
    
    遵循“在隔离环境中重建真实状态”的原则。
    使用 setUpTestData 加载所有测试共享的、不变的配置数据。
    使用 setUp 和 tearDown 管理每个具体测试的生命周期和结果记录。
    """
    
    @classmethod
    def setUpTestData(cls):
        """
        在整个测试类运行前执行一次，用于准备共享的、不变的“背景”数据。
        这是填充测试数据库以模拟真实配置的最佳位置。
        """
        print("\n" + "="*50)
        print(f"[{cls.__name__}] Running setUpTestData: Populating test database with initial configuration...")
        
        # 示例：如何从真实数据源（如JSON文件或直接查询）加载配置
        # 注意：这里操作的是【测试数据库】
        # 你可以在这里编写代码，一次性地将你需要的“真实”配置读入内存，
        # 然后创建到测试数据库中。
        try:
            # 使用事务确保数据加载的原子性
            with transaction.atomic():
                # InfraConfig.objects.create(...)
                # InfraConfig.objects.create(...)
                # ...
                # 假设我们创建了两个配置项
                pass # 这里替换为你的真实配置创建逻辑
                
            print(f"[{cls.__name__}] setUpTestData completed successfully.")
        except Exception as e:
            print(f"[{cls.__name__}] CRITICAL: Failed to set up test data: {e}")
            # 如果基础配置失败，后续测试可能无意义，可以选择抛出异常
            raise
        print("="*50)

    def setUp(self):
        """
        在每个 test_ 方法执行前运行。
        用于设置日志、创建输出目录、记录初始状态等每个测试都需要独立完成的工作。
        """
        # --- 文件和日志设置 ---
        self.output_dir = os.path.join(settings.BASE_DIR, 'test_outputs')
        os.makedirs(self.output_dir, exist_ok=True)
        
        # 使用符合规范的文件命名格式
        test_method_name = self._testMethodName
        timestamp = datetime.now()
        date_str = timestamp.strftime('%Y%m%d')
        time_str = timestamp.strftime('%H%M%S')
        
        # 生成符合规范的文件名
        self.process_filename = f'process-{date_str}-{time_str}-{test_method_name}.json'
        self.log_filename = f'log-{date_str}-{time_str}-{test_method_name}.log'
        
        self.setup_logging()
        self.logger.info(f"Test method '{test_method_name}' starting...")
        
        # --- 状态捕获和数据记录 ---
        self.initial_state = self.capture_state("initial")
        self.process_data = {
            "test_info": {
                "name": f"{self.__class__.__name__}.{test_method_name}",
                "start_time": datetime.now().isoformat()
            },
            "initial_state": self.initial_state,
            "execution_steps": []
        }

    def setup_logging(self):
        """配置日志记录器"""
        log_file = os.path.join(self.output_dir, self.log_filename)
        
        # 避免重复添加handler
        self.logger = logging.getLogger(self.log_filename)
        if not self.logger.handlers:
            self.logger.setLevel(logging.DEBUG)
            formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            
            # 文件处理器
            fh = logging.FileHandler(log_file, encoding='utf-8')
            fh.setFormatter(formatter)
            self.logger.addHandler(fh)
            
            # 控制台处理器
            sh = logging.StreamHandler()
            sh.setFormatter(formatter)
            self.logger.addHandler(sh)
            
    def capture_state(self, stage: str):
        """
        捕获当前数据库和配置的状态。
        
        stage: 'initial' 或 'final'
        """
        self.logger.info(f"Capturing {stage} state...")
        # 【实现】在这里添加捕获数据库相关表快照的逻辑
        # 例如，序列化你关心的模型对象
        # db_snapshot = {"InfraConfig": list(InfraConfig.objects.values())}
        db_snapshot = {"TODO": "Implement database state capture logic here"}
        return {
            "database": db_snapshot
        }

    def record_step(self, action, input_data, output_data, **kwargs):
        """记录执行步骤"""
        step_number = len(self.process_data["execution_steps"]) + 1
        step_data = {
            "step": step_number,
            "action": action,
            "input": str(input_data), # 确保可序列化
            "output": str(output_data), # 确保可序列化
            "timestamp": datetime.now().isoformat(),
            **kwargs
        }
        self.process_data["execution_steps"].append(step_data)
        self.logger.info(f"Step {step_number}: {action} recorded.")
    
    def tearDown(self):
        """
        在每个 test_ 方法执行后运行。
        用于记录最终状态和保存所有输出文件。
        """
        end_time = datetime.now()
        start_time_iso = self.process_data["test_info"]["start_time"]
        start_time = datetime.fromisoformat(start_time_iso)
        duration = (end_time - start_time).total_seconds()

        self.process_data["test_info"]["end_time"] = end_time.isoformat()
        self.process_data["test_info"]["duration"] = duration
        self.process_data["final_state"] = self.capture_state("final")
        
        # 保存过程数据
        process_file = os.path.join(self.output_dir, self.process_filename)
        try:
            with open(process_file, 'w', encoding='utf-8') as f:
                json.dump(self.process_data, f, ensure_ascii=False, indent=2, default=str)
        except Exception as e:
            self.logger.error(f"Failed to write process file: {e}")

        self.logger.info(f"Test method finished. Duration: {duration:.2f}s")
        print(f"\n[INFO] Test outputs saved to directory: {os.path.abspath(self.output_dir)}")
        # Django 测试运行器会处理日志处理器的关闭
```

## 输出文件命名规范

测试产生的所有输出文件必须遵循以下命名格式：

### 文件命名格式
```
[文件类型]-[日期]-[时间]-[测试名称].[扩展名]
```

#### 具体规则：
- **文件类型**：`process`（过程数据）、`log`（日志文件）、`result`（结果文件）等
- **日期格式**：`YYYYMMDD`（如 20250922）
- **时间格式**：`HHMMSS`（如 143022）
- **测试名称**：测试方法名（如 test_runtime_state_creation）
- **扩展名**：根据文件类型（.json、.log、.txt等）

#### 示例：
```
process-20250922-143022-test_runtime_state_creation.json
log-20250922-143022-test_runtime_state_creation.log
result-20250922-143022-test_performance.json
```

#### 实现代码：
```python
def setUp(self):
    """设置测试环境"""
    # 生成符合规范的文件名
    test_method_name = self._testMethodName
    timestamp = datetime.now()
    date_str = timestamp.strftime('%Y%m%d')
    time_str = timestamp.strftime('%H%M%S')
    
    # 过程数据文件名
    self.process_filename = f'process-{date_str}-{time_str}-{test_method_name}.json'
    # 日志文件名
    self.log_filename = f'log-{date_str}-{time_str}-{test_method_name}.log'
```

### 修改摘要和理由

1.  **引入 `setUpTestData`**:
    *   **做什么**: 在这个类方法中，我们一次性地将所有测试方法都需要的、不变的配置数据创建到**测试数据库**中。
    *   **为什么**:
        *   **效率**: 避免了在每个 `setUp` 中重复创建相同的配置数据，大大加快了测试套件的执行速度。
        *   **清晰**: 将“环境准备”和“用例准备”分离。`setUpTestData` 负责构建一个稳定的、可用的测试“世界”，`setUp` 则负责为每个测试在这个“世界”里摆放道具。
        *   **一致性**: 保证了同一个测试类下的所有测试方法都运行在完全相同的初始配置之上。

2.  **`setUp` 的职责调整**:
    *   **做什么**: `setUp` 现在专注于那些**每个测试都需要独立初始化的部分**，比如设置带有唯一时间戳的日志文件、记录特定于该测试的初始状态。
    *   **为什么**: 日志文件、测试开始时间、初始状态快照等都应该是每个测试独有的，放在`setUp`中可以确保它们不会被前一个测试污染。

3.  **模板代码的健壮性改进**:
    *   为日志和输出文件名加入了方法名和更精确的时间戳，防止在同一秒内运行多个测试时文件名冲突。
    *   为日志器增加了 `if not self.logger.handlers:` 判断，防止因测试运行器的复杂行为导致重复添加处理器。
    *   在 `json.dump` 中增加了 `default=str`，以处理一些无法直接序列化的数据类型（如 `datetime` 对象，尽管模板中已处理）。
