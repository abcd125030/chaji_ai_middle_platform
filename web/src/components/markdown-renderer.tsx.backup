'use client';

import React, { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import rehypeRaw from 'rehype-raw';
import rehypeKatex from 'rehype-katex';
import katex from 'katex';
import 'katex/dist/katex.min.css';
import type { Components } from 'react-markdown';

interface MarkdownRendererProps {
  content: string;
  baseUrl?: string;
}

interface ImageViewerProps {
  src: string;
  alt: string;
  onClose: () => void;
}

// å›¾ç‰‡æŸ¥çœ‹å™¨ç»„ä»¶
const ImageViewer: React.FC<ImageViewerProps> = ({ src, alt, onClose }) => {
  const [scale, setScale] = useState(1);

  const handleWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    const delta = e.deltaY * -0.001;
    const newScale = Math.min(Math.max(0.5, scale + delta), 3);
    setScale(newScale);
  };

  return (
    <div
      className="fixed inset-0 z-50 bg-black/90 flex items-center justify-center"
      onClick={onClose}
    >
      <button
        className="absolute top-4 right-4 text-white text-2xl hover:text-gray-300"
        onClick={onClose}
      >
        âœ•
      </button>
      <div
        className="relative max-w-[90vw] max-h-[90vh] overflow-auto"
        onClick={(e) => e.stopPropagation()}
        onWheel={handleWheel}
      >
        {/* eslint-disable-next-line @next/next/no-img-element */}
        <img
          src={src}
          alt={alt}
          style={{ transform: `scale(${scale})` }}
          className="transition-transform duration-200"
        />
      </div>
      <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 text-white text-sm">
        æ»šè½®ç¼©æ”¾ â€¢ ç‚¹å‡»èƒŒæ™¯å…³é—­
      </div>
    </div>
  );
};

// Markdownæ¸²æŸ“å™¨ç»„ä»¶
export const MarkdownRenderer: React.FC<MarkdownRendererProps> = ({
  content,
  baseUrl = ''
}) => {
  const [viewerImage, setViewerImage] = useState<{ src: string; alt: string } | null>(null);

  // å¤„ç†å›¾ç‰‡URL
  const processImageUrl = (url: string): string => {
    if (url.startsWith('http')) {
      return url;
    }
    if (url.startsWith('/media/')) {
      return `${baseUrl}${url}`;
    }
    return url;
  };

  // è‡ªå®šä¹‰ç»„ä»¶é…ç½®
  const components: Components = {
    // æ•°å­¦å…¬å¼ï¼ˆæ ¸å¿ƒä¿®å¤ï¼šç›´æ¥ä½¿ç”¨ katex æ¸²æŸ“ï¼Œé¿å… HTML è½¬ä¹‰ï¼‰
    code: ({ inline, className, children, ...props }: any) => {
      const match = /language-(\w+)/.exec(className || '');
      const value = String(children).replace(/\n$/, '');

      // å¤„ç† LaTeX æ•°å­¦å…¬å¼
      if (className === 'language-math' && !inline) {
        console.log('[è‡ªå®šä¹‰ code ç»„ä»¶] æ¸²æŸ“å—å…¬å¼ï¼ŒåŸå§‹å€¼:', value);
        // è¿˜åŸè¢«ä¿æŠ¤çš„ &
        const restoredValue = value.replace(/__LATEX_AMP__/g, '&');
        console.log('[è‡ªå®šä¹‰ code ç»„ä»¶] è¿˜åŸå:', restoredValue);

        try {
          const html = katex.renderToString(restoredValue, {
            displayMode: true,
            throwOnError: false,
            strict: false,
            trust: true
          });
          return <div dangerouslySetInnerHTML={{ __html: html }} />;
        } catch (e) {
          console.error('[è‡ªå®šä¹‰ code ç»„ä»¶] KaTeX æ¸²æŸ“é”™è¯¯:', e);
          return <code className="katex-error">{value}</code>;
        }
      }

      // å¤„ç†è¡Œå†… LaTeX å…¬å¼
      if (className === 'language-math' && inline) {
        const restoredValue = value.replace(/__LATEX_AMP__/g, '&');
        try {
          const html = katex.renderToString(restoredValue, {
            displayMode: false,
            throwOnError: false,
            strict: false,
            trust: true
          });
          return <span dangerouslySetInnerHTML={{ __html: html }} />;
        } catch (e) {
          console.error('[è‡ªå®šä¹‰ code ç»„ä»¶] KaTeX æ¸²æŸ“é”™è¯¯:', e);
          return <code className="katex-error">{value}</code>;
        }
      }

      // å¤„ç†æ™®é€šä»£ç å—
      if (!inline && match) {
        return (
          <code className={`${className || ''} text-[#EDEDED] font-mono text-sm`} {...props}>
            {children}
          </code>
        );
      }

      // å¤„ç†è¡Œå†…ä»£ç 
      return (
        <code
          className="bg-[#0A0A0A] text-[#EDEDED] px-1.5 py-0.5 rounded text-sm font-mono border border-[#1A1A1A]"
          {...props}
        >
          {children}
        </code>
      );
    },

    // æ ‡é¢˜
    h1: ({ children, ...props }) => (
      <h1 className="text-2xl font-bold mt-6 mb-4 text-white border-b border-[#1A1A1A] pb-2" {...props}>
        {children}
      </h1>
    ),
    h2: ({ children, ...props }) => (
      <h2 className="text-xl font-bold mt-5 mb-3 text-white" {...props}>
        {children}
      </h2>
    ),
    h3: ({ children, ...props }) => (
      <h3 className="text-lg font-semibold mt-4 mb-2 text-[#EDEDED]" {...props}>
        {children}
      </h3>
    ),
    h4: ({ children, ...props }) => (
      <h4 className="text-base font-semibold mt-3 mb-2 text-[#EDEDED]" {...props}>
        {children}
      </h4>
    ),
    h5: ({ children, ...props }) => (
      <h5 className="text-sm font-semibold mt-2 mb-1 text-[#EDEDED]" {...props}>
        {children}
      </h5>
    ),
    h6: ({ children, ...props }) => (
      <h6 className="text-xs font-semibold mt-2 mb-1 text-[#888888]" {...props}>
        {children}
      </h6>
    ),

    // æ®µè½
    p: ({ children, ...props }) => (
      <p className="mb-4 text-[#EDEDED] leading-relaxed" {...props}>
        {children}
      </p>
    ),

    // åˆ—è¡¨
    ul: ({ children, ...props }) => (
      <ul className="mb-4 ml-6 list-disc text-[#EDEDED] space-y-1" {...props}>
        {children}
      </ul>
    ),
    ol: ({ children, ...props }) => (
      <ol className="mb-4 ml-6 list-decimal text-[#EDEDED] space-y-1" {...props}>
        {children}
      </ol>
    ),
    li: ({ children, ...props }) => (
      <li className="mb-1" {...props}>
        {children}
      </li>
    ),

    // å¼•ç”¨
    blockquote: ({ children, ...props }) => (
      <blockquote
        className="border-l-4 border-[#888888] pl-4 py-2 mb-4 text-[#888888] italic bg-[#0A0A0A] rounded-r"
        {...props}
      >
        {children}
      </blockquote>
    ),

    // pre ä»£ç å—å®¹å™¨
    pre: ({ children, ...props }) => (
      <pre
        className="bg-[#0A0A0A] p-4 rounded-lg mb-4 overflow-x-auto border border-[#1A1A1A]"
        {...props}
      >
        {children}
      </pre>
    ),

    // è¡¨æ ¼
    table: ({ children, ...props }) => (
      <div className="mb-4 overflow-x-auto">
        <table className="min-w-full border-collapse border border-[#1A1A1A]" {...props}>
          {children}
        </table>
      </div>
    ),
    thead: ({ children, ...props }) => (
      <thead className="bg-[#0A0A0A]" {...props}>
        {children}
      </thead>
    ),
    tbody: ({ children, ...props }) => (
      <tbody {...props}>
        {children}
      </tbody>
    ),
    tr: ({ children, ...props }) => (
      <tr className="border-b border-[#1A1A1A] hover:bg-[#0A0A0A] transition-colors" {...props}>
        {children}
      </tr>
    ),
    th: ({ children, ...props }) => (
      <th className="border border-[#1A1A1A] px-4 py-2 text-left text-white font-semibold" {...props}>
        {children}
      </th>
    ),
    td: ({ children, ...props }) => (
      <td className="border border-[#1A1A1A] px-4 py-2 text-[#EDEDED]" {...props}>
        {children}
      </td>
    ),

    // é“¾æ¥
    a: ({ href, children, ...props }) => (
      <a
        href={href}
        className="text-blue-400 hover:text-blue-300 underline transition-colors"
        target="_blank"
        rel="noopener noreferrer"
        {...props}
      >
        {children}
      </a>
    ),

    // å›¾ç‰‡
    img: ({ src, alt, ...props }) => {
      const srcString = typeof src === 'string' ? src : '';
      const imgSrc = processImageUrl(srcString);
      return (
        <span
          className="inline-block my-4 cursor-pointer"
          onClick={() => setViewerImage({ src: imgSrc, alt: alt || '' })}
        >
          {/* eslint-disable-next-line @next/next/no-img-element */}
          <img
            src={imgSrc}
            alt={alt || ''}
            className="max-w-full h-auto rounded-lg border border-[#1A1A1A] hover:border-[#888888] transition-colors"
            loading="lazy"
            onError={(e) => {
              const img = e.target as HTMLImageElement;
              // è®¾ç½®å ä½å›¾
              img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iIzFhMWExYSIvPgogIDx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTgiIGZpbGw9IiM4ODg4ODgiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj7lm77niYfliqDovb3lpLHotKU8L3RleHQ+Cjwvc3ZnPg==';
              img.style.maxWidth = '400px';
              img.style.maxHeight = '300px';
            }}
            {...props}
          />
        </span>
      );
    },

    // æ°´å¹³åˆ†å‰²çº¿
    hr: ({ ...props }) => (
      <hr className="my-6 border-[#1A1A1A]" {...props} />
    ),

    // å¼ºè°ƒ
    strong: ({ children, ...props }) => (
      <strong className="font-bold text-white" {...props}>
        {children}
      </strong>
    ),
    em: ({ children, ...props }) => (
      <em className="italic text-[#EDEDED]" {...props}>
        {children}
      </em>
    ),
  };

  // é¢„å¤„ç† markdown å†…å®¹ï¼ˆä¿ç•™åŸºæœ¬æ ¼å¼åŒ–ï¼‰
  const preprocessContent = (text: string): string => {
    console.log('[MarkdownRenderer] 1ï¸âƒ£ åŸå§‹å†…å®¹æ€»é•¿åº¦:', text.length);

    // æ¸…ç†è¿ç»­çš„å¤šä¸ªç©ºè¡Œä¸ºæœ€å¤š2ä¸ªç©ºè¡Œ
    text = text.replace(/\n{3,}/g, '\n\n');

    console.log('[MarkdownRenderer] 2ï¸âƒ£ é¢„å¤„ç†åæ€»é•¿åº¦:', text.length);

    return text;
  };

  // è‡ªå®šä¹‰ remark æ’ä»¶ï¼šè¿˜åŸè¢«ä¿æŠ¤çš„ & å­—ç¬¦
  const remarkRestoreAmpersand = () => {
    return (tree: any) => {
      // é€’å½’éå†æ‰€æœ‰èŠ‚ç‚¹
      const restore = (node: any) => {
        // å¤„ç† inlineMath å’Œ math èŠ‚ç‚¹
        if ((node.type === 'inlineMath' || node.type === 'math') && node.value) {
          if (node.value.includes('__LATEX_AMP__')) {
            console.log('[remarkRestoreAmpersand] ğŸ”“ è¿˜åŸå‰:', node.value.substring(0, 100));
            node.value = node.value.replace(/__LATEX_AMP__/g, '&');
            console.log('[remarkRestoreAmpersand] ğŸ”“ è¿˜åŸå:', node.value.substring(0, 100));
          }
        }

        // é€’å½’å¤„ç†å­èŠ‚ç‚¹
        if (node.children) {
          node.children.forEach(restore);
        }
      };

      restore(tree);
    };
  };

  // è¿˜åŸæ’ä»¶ï¼šåœ¨ rehypeKatex ä¹‹å‰ï¼Œå°†æ•°å­¦èŠ‚ç‚¹ä¸­çš„ &amp; è¿˜åŸä¸º &
  const rehypeRestoreAmpersand = () => {
    return (tree: any) => {
      console.log('[rehypeRestoreAmpersand] ğŸ”§ å¼€å§‹ä¿®å¤ &amp; è½¬ä¹‰');

      let fixedCount = 0;
      const process = (node: any, parent: any) => {
        // æ£€æŸ¥æ˜¯å¦æ˜¯æ•°å­¦å…¬å¼èŠ‚ç‚¹ï¼ˆcode with language-math classï¼‰
        const isMathNode =
          node.type === 'element' &&
          node.tagName === 'code' &&
          node.properties?.className &&
          (node.properties.className.includes('language-math') ||
           node.properties.className.includes('math-inline') ||
           node.properties.className.includes('math-display'));

        if (isMathNode && node.children) {
          // éå†å­èŠ‚ç‚¹ï¼ˆæ–‡æœ¬èŠ‚ç‚¹ï¼‰
          node.children.forEach((child: any) => {
            if (child.type === 'text' && child.value && child.value.includes('&amp;')) {
              console.log('[rehypeRestoreAmpersand] æ‰¾åˆ°æ•°å­¦èŠ‚ç‚¹ä¸­çš„ &amp;:', child.value.substring(0, 100));
              child.value = child.value.replace(/&amp;/g, '&');
              fixedCount++;
              console.log('[rehypeRestoreAmpersand] âœ… ä¿®å¤å:', child.value.substring(0, 100));
            }
          });
        }

        // é€’å½’å¤„ç†å­èŠ‚ç‚¹
        if (node.children) {
          node.children.forEach((child: any) => process(child, node));
        }
      };

      process(tree, null);
      console.log(`[rehypeRestoreAmpersand] ğŸ”§ å®Œæˆï¼Œå…±ä¿®å¤ ${fixedCount} ä¸ªèŠ‚ç‚¹`);
    };
  };

  // è°ƒè¯•æ’ä»¶ï¼šæ£€æŸ¥ rehypeKatex ä¹‹åçš„çŠ¶æ€
  const rehypeDebugAfterKatex = () => {
    return (tree: any) => {
      console.log('[rehypeDebugAfterKatex] ğŸ“‹ æ£€æŸ¥ rehypeKatex å¤„ç†åçš„ç»“æœ');

      const process = (node: any) => {
        // æŸ¥æ‰¾ katex ç›¸å…³çš„èŠ‚ç‚¹
        if (node.type === 'element' && node.properties?.className) {
          const classes = node.properties.className;
          if (classes.includes('katex') || classes.includes('katex-error')) {
            console.log('[rehypeDebugAfterKatex] æ‰¾åˆ° KaTeX èŠ‚ç‚¹:', {
              tagName: node.tagName,
              className: classes,
              children: node.children ? node.children.length : 0
            });

            // å¦‚æœæ˜¯é”™è¯¯èŠ‚ç‚¹ï¼Œæ‰“å°é”™è¯¯ä¿¡æ¯
            if (classes.includes('katex-error') && node.properties?.title) {
              console.error('[rehypeDebugAfterKatex] âŒ KaTeX é”™è¯¯:', node.properties.title);
            }

            // æ‰“å°éƒ¨åˆ†å†…å®¹
            if (node.children && node.children.length > 0) {
              console.log('[rehypeDebugAfterKatex] å­èŠ‚ç‚¹ç‰‡æ®µ:', JSON.stringify(node.children[0], null, 2).substring(0, 300));
            }
          }
        }

        // æ£€æŸ¥æ–‡æœ¬èŠ‚ç‚¹ä¸­æ˜¯å¦è¿˜æœ‰ & ç›¸å…³å†…å®¹
        if (node.type === 'text' && node.value) {
          if (node.value.includes('&amp;')) {
            console.warn('[rehypeDebugAfterKatex] âš ï¸ å‘ç° &amp;:', node.value.substring(0, 100));
          }
          if (node.value.includes('array')) {
            console.log('[rehypeDebugAfterKatex] åŒ…å« array çš„æ–‡æœ¬:', node.value.substring(0, 100));
          }
        }

        // é€’å½’å¤„ç†å­èŠ‚ç‚¹
        if (node.children) {
          node.children.forEach((child: any) => process(child));
        }
      };

      process(tree);
      console.log('[rehypeDebugAfterKatex] ğŸ“‹ æ£€æŸ¥å®Œæˆ');
    };
  };

  // KaTeX é…ç½®é€‰é¡¹
  const katexOptions = {
    strict: false as const,  // ç¦ç”¨ä¸¥æ ¼æ¨¡å¼ï¼Œå…è®¸Unicodeå­—ç¬¦
    trust: true,             // ä¿¡ä»»æ‰€æœ‰è¾“å…¥
    throwOnError: false,     // é‡åˆ°é”™è¯¯æ—¶ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œè€Œæ˜¯æ¸²æŸ“ä¸ºçº¢è‰²
    errorColor: '#cc0000',   // é”™è¯¯é¢œè‰²
    fleqn: false,            // ä¸å¼ºåˆ¶å·¦å¯¹é½
    macros: {
      "\\eqref": "\\href{###1}{(\\text{#1})}",
      "\\ref": "\\href{###1}{\\text{#1}}",
      "\\label": "\\htmlId{#1}{}"
    }
  };

  const processedContent = preprocessContent(content);

  console.log('[MarkdownRenderer] 3ï¸âƒ£ ä¼ é€’ç»™ ReactMarkdown çš„å†…å®¹å‡†å¤‡å°±ç»ª');

  return (
    <>
      <div className="markdown-content text-[#EDEDED] text-sm leading-relaxed">
        <ReactMarkdown
          remarkPlugins={[
            remarkGfm,
            [remarkMath, { singleDollarTextMath: true }]  // æ˜¾å¼å¯ç”¨å•$è¡Œå†…å…¬å¼æ”¯æŒ
          ]}
          rehypePlugins={[
            rehypeRaw,  // å¤„ç† HTML
            rehypeRestoreAmpersand,  // ã€æ ¸å¿ƒä¿®å¤ã€‘è¿˜åŸ __LATEX_AMP__ ä¸º &
            [rehypeKatex, katexOptions],  // KaTeX æ¸²æŸ“ï¼ˆæ­¤æ—¶ & å·²è¿˜åŸï¼‰
            rehypeDebugAfterKatex  // ã€è°ƒè¯•ã€‘æ£€æŸ¥ rehypeKatex ä¹‹åçš„ç»“æœ
          ]}
          components={components}
        >
          {processedContent}
        </ReactMarkdown>
      </div>

      {viewerImage && (
        <ImageViewer
          src={viewerImage.src}
          alt={viewerImage.alt}
          onClose={() => setViewerImage(null)}
        />
      )}
    </>
  );
};